
//LC- 924. Minimize Malware Spread

    // solving with bfs ->
    // haam arr me haar element baari baari hata ke then total number of infected node calculate kar lege 
    // and jiss bhi node ke liye haame sabse kaam total number of infected nodes milege vo and hoga
    // and if agar ek se jada node ese mile jisnka totalnumberofinfected nodes same ha then unme se sabse kaam number vala hamara ans hoga(NOTE question me galat diya ha ki smallest index return karna ha nahi wrong ha vo, haame actual me smallest node return karna ha)
    public int minMalwareSpread(int[][] g, int[] arr) {
        int  n = g.length;
        // build graph
        HashSet<Integer>[] graph = new HashSet[n];
        for(int i = 0; i < n; i++) graph[i] = new HashSet<>();
        for(int i = 0; i < g.length; i++){
            for(int j = i+1; j < g[0].length; j++){
                if(g[i][j] == 1){
                    graph[i].add(j);
                    graph[j].add(i);
                }
            }
        }
        Arrays.sort(arr);  // question me unko smallest number vala answer chahiye smallest index vala nahi isliye sort kiya
        
        int m = arr.length;
        int[] ans = new int[m];
        int k = 0;
        boolean[] taken = new boolean[m];
        int minval = (int)1e9;
        for(int i = 0; i < m; i++){
            taken[i] = true;
            int val = bfs(graph, arr, taken);
            
            ans[k++] = val;
            minval = Math.min(minval, val);
            taken[i] = false;
        }
        
        for(int i = 0; i < n; i++){
            if(ans[i] == minval) return arr[i];
        }
        
        return -1;
    }
    
    public int bfs(HashSet<Integer>[] graph, int[] arr,boolean[] taken){
        LinkedList<Integer> que = new LinkedList<>();
        
        int n = graph.length, count = 0;
        boolean[] vis = new boolean[n];
        for(int i = 0; i < arr.length; i++){
            int x = arr[i];
            if(taken[i] == false){
                que.add(x);
            }
        } 
        
        while(que.size() != 0){
            int rem = que.removeFirst();  // r

            if(vis[rem]){ // m*
                continue;
            }
            vis[rem] = true;

            count++;  // w

            for(int v : graph[rem]){  // a*
                if(!vis[v])  que.addLast(v);
            }
        }
        return count;
    }


//========================================================================================================


    // LC - 928. Minimize Malware Spread II
    // solving with bfs ->
    // haam arr me haar element baari baari hata ke then total number of infected node calculate kar lege 
    // and jiss bhi node ke liye haame sabse kaam total number of infected nodes milege vo and hoga
    // and if agar ek se jada node ese mile jisnka totalnumberofinfected nodes same ha then unme se sabse kaam number vala hamara ans hoga(NOTE question me galat diya ha ki smallest index return karna ha nahi wrong ha vo, haame actual me smallest node return karna ha)
    // BASS YAHA PE YE DIFFERENCE HA ISS QUESTION ME UPAR VALE SE KI 
    // YAHA HAAM JAB ELEMENT REMOVE KAREGE given arr ME SE THEN HAAM USKO GRAPH SE BHI REMOVE KAR DEGE YAHI EXTRA HA BASS ISS QUESTION ME 
    
    public int minMalwareSpread(int[][] g, int[] arr) {
        int n = g.length;
        HashSet<Integer>[] graph = new HashSet[n];
        for(int i = 0; i < n; i++) graph[i] = new HashSet<>();
        for(int i = 0; i < n; i++){
            for(int j = i+1; j < n; j++){
                if(g[i][j] == 1){
                    graph[i].add(j);
                    graph[j].add(i);
                }
            }
        }
        
        Arrays.sort(arr);
        int m = arr.length;
        int minans = (int)1e9;
        int[] ans = new int[m];
        
        boolean[] taken = new boolean[m];
        for(int i = 0; i < m; i++){
            int vtx = arr[i];
            remove(graph, vtx);
            taken[i] = true;
        
            ans[i] = bfs(graph, arr, vtx, taken);
            
            minans = Math.min(minans, ans[i]);
            taken[i] = false;
            add(graph, g, vtx);
        }
        
        for(int i = 0; i < m; i++){
            if(minans == ans[i]) return arr[i];
        }
        return 0;
    }

    public int bfs(HashSet<Integer>[] graph, int[] arr, int vtx, boolean[] taken){
        Queue<Integer> que = new LinkedList<>();
        int n = graph.length;
        for(int i = 0; i < arr.length; i++){
            if(!taken[i]) que.add(arr[i]);
        }
        boolean[] vis = new boolean[n];
        int count = 0;
        while(que.size() != 0){
            int rem = que.remove();  // r
            
            if(vis[rem]) continue;  // m*
            vis[rem] = true;
            
            // w
            count++;
            
            //a*
            for(int v : graph[rem]){
                if(!vis[v]){
                    que.add(v);
                }
            }
        }
        return count;
    }


    public void remove(HashSet<Integer>[] graph, int vtx){
        for(Integer v : graph[vtx]){
            graph[v].remove(vtx);
        }
        
        graph[vtx] = new HashSet<>();
    }

    public void add(HashSet<Integer>[] graph, int[][] g, int vtx){
        // vtx ke row me chal ke dektna ha ki nbr kon ha
        for(int j = 0; j < g[0].length; j++){
            if(g[vtx][j] == 1 && vtx != j){
                graph[vtx].add(j);
                graph[j].add(vtx);
            }
        }
        
        // vtx ke col me chal ke dektna ha ki nbr kon ha
        for(int i = 0; i < g[0].length; i++){
            if(g[i][vtx] == 1 && i != vtx){
                graph[vtx].add(i);
                graph[i].add(vtx);
            }
        }
    }


