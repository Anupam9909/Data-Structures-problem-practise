
//LC- 924. Minimize Malware Spread

    // solving with bfs ->
    // haam arr me haar element baari baari hata ke then total number of infected node calculate kar lege 
    // and jiss bhi node ke liye haame sabse kaam total number of infected nodes milege vo and hoga
    // and if agar ek se jada node ese mile jisnka totalnumberofinfected nodes same ha then unme se sabse kaam number vala hamara ans hoga(NOTE question me galat diya ha ki smallest index return karna ha nahi wrong ha vo, haame actual me smallest node return karna ha)
    public int minMalwareSpread(int[][] g, int[] arr) {
        int  n = g.length;
        // build graph
        HashSet<Integer>[] graph = new HashSet[n];
        for(int i = 0; i < n; i++) graph[i] = new HashSet<>();
        for(int i = 0; i < g.length; i++){
            for(int j = i+1; j < g[0].length; j++){
                if(g[i][j] == 1){
                    graph[i].add(j);
                    graph[j].add(i);
                }
            }
        }
        Arrays.sort(arr);  // question me unko smallest number vala answer chahiye smallest index vala nahi isliye sort kiya
        
        int m = arr.length;
        int[] ans = new int[m];
        int k = 0;
        boolean[] taken = new boolean[m];
        int minval = (int)1e9;
        for(int i = 0; i < m; i++){
            taken[i] = true;
            int val = bfs(graph, arr, taken);
            
            ans[k++] = val;
            minval = Math.min(minval, val);
            taken[i] = false;
        }
        
        for(int i = 0; i < n; i++){
            if(ans[i] == minval) return arr[i];
        }
        
        return -1;
    }
    
    public int bfs(HashSet<Integer>[] graph, int[] arr,boolean[] taken){
        LinkedList<Integer> que = new LinkedList<>();
        
        int n = graph.length, count = 0;
        boolean[] vis = new boolean[n];
        for(int i = 0; i < arr.length; i++){
            int x = arr[i];
            if(taken[i] == false){
                que.add(x);
            }
        } 
        
        while(que.size() != 0){
            int rem = que.removeFirst();  // r

            if(vis[rem]){ // m*
                continue;
            }
            vis[rem] = true;

            count++;  // w

            for(int v : graph[rem]){  // a*
                if(!vis[v])  que.addLast(v);
            }
        }
        return count;
    }


//========================================================================================================





