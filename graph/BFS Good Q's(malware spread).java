
//LC- 924. Minimize Malware Spread

    // solving with bfs ->
    // haam arr me haar element baari baari hata ke then total number of infected node calculate kar lege 
    // and jiss bhi node ke liye haame sabse kaam total number of infected nodes milege vo and hoga
    // and if agar ek se jada node ese mile jisnka totalnumberofinfected nodes same ha then unme se sabse kaam number vala hamara ans hoga(NOTE question me galat diya ha ki smallest index return karna ha nahi wrong ha vo, haame actual me smallest node return karna ha)
    public int minMalwareSpread(int[][] g, int[] arr) {
        int  n = g.length;
        // build graph
        HashSet<Integer>[] graph = new HashSet[n];
        for(int i = 0; i < n; i++) graph[i] = new HashSet<>();
        for(int i = 0; i < g.length; i++){
            for(int j = i+1; j < g[0].length; j++){
                if(g[i][j] == 1){
                    graph[i].add(j);
                    graph[j].add(i);
                }
            }
        }
        Arrays.sort(arr);  // question me unko smallest number vala answer chahiye smallest index vala nahi isliye sort kiya
        
        int m = arr.length;
        int[] ans = new int[m];
        int k = 0;
        boolean[] taken = new boolean[m];
        int minval = (int)1e9;
        for(int i = 0; i < m; i++){
            taken[i] = true;
            int val = bfs(graph, arr, taken);
            
            ans[k++] = val;
            minval = Math.min(minval, val);
            taken[i] = false;
        }
        
        for(int i = 0; i < n; i++){
            if(ans[i] == minval) return arr[i];
        }
        
        return -1;
    }
    
    public int bfs(HashSet<Integer>[] graph, int[] arr,boolean[] taken){
        LinkedList<Integer> que = new LinkedList<>();
        
        int n = graph.length, count = 0;
        boolean[] vis = new boolean[n];
        for(int i = 0; i < arr.length; i++){
            int x = arr[i];
            if(taken[i] == false){
                que.add(x);
            }
        } 
        
        while(que.size() != 0){
            int rem = que.removeFirst();  // r

            if(vis[rem]){ // m*
                continue;
            }
            vis[rem] = true;

            count++;  // w

            for(int v : graph[rem]){  // a*
                if(!vis[v])  que.addLast(v);
            }
        }
        return count;
    }


//========================================================================================================


    // LC - 928. Minimize Malware Spread II
    // solving with bfs ->
    // haam arr me haar element baari baari hata ke then total number of infected node calculate kar lege 
    // and jiss bhi node ke liye haame sabse kaam total number of infected nodes milege vo and hoga
    // and if agar ek se jada node ese mile jisnka totalnumberofinfected nodes same ha then unme se sabse kaam number vala hamara ans hoga(NOTE question me galat diya ha ki smallest index return karna ha nahi wrong ha vo, haame actual me smallest node return karna ha)
    // BASS YAHA PE YE DIFFERENCE HA ISS QUESTION ME UPAR VALE SE KI 
    // YAHA HAAM JAB ELEMENT REMOVE KAREGE given arr ME SE THEN HAAM USKO GRAPH SE BHI REMOVE KAR DEGE YAHI EXTRA HA BASS ISS QUESTION ME 
    
    public int minMalwareSpread(int[][] g, int[] arr) {
        int n = g.length;
        HashSet<Integer>[] graph = new HashSet[n];
        for(int i = 0; i < n; i++) graph[i] = new HashSet<>();
        for(int i = 0; i < n; i++){
            for(int j = i+1; j < n; j++){
                if(g[i][j] == 1){
                    graph[i].add(j);
                    graph[j].add(i);
                }
            }
        }
        
        Arrays.sort(arr);
        int m = arr.length;
        int minans = (int)1e9;
        int[] ans = new int[m];
        
        boolean[] taken = new boolean[m];
        for(int i = 0; i < m; i++){
            int vtx = arr[i];
            remove(graph, vtx);
            taken[i] = true;
        
            ans[i] = bfs(graph, arr, vtx, taken);
            
            minans = Math.min(minans, ans[i]);
            taken[i] = false;
            add(graph, g, vtx);
        }
        
        for(int i = 0; i < m; i++){
            if(minans == ans[i]) return arr[i];
        }
        return 0;
    }

    public int bfs(HashSet<Integer>[] graph, int[] arr, int vtx, boolean[] taken){
        Queue<Integer> que = new LinkedList<>();
        int n = graph.length;
        for(int i = 0; i < arr.length; i++){
            if(!taken[i]) que.add(arr[i]);
        }
        boolean[] vis = new boolean[n];
        int count = 0;
        while(que.size() != 0){
            int rem = que.remove();  // r
            
            if(vis[rem]) continue;  // m*
            vis[rem] = true;
            
            // w
            count++;
            
            //a*
            for(int v : graph[rem]){
                if(!vis[v]){
                    que.add(v);
                }
            }
        }
        return count;
    }


    public void remove(HashSet<Integer>[] graph, int vtx){
        for(Integer v : graph[vtx]){
            graph[v].remove(vtx);
        }
        
        graph[vtx] = new HashSet<>();
    }

    public void add(HashSet<Integer>[] graph, int[][] g, int vtx){
        // vtx ke row me chal ke dektna ha ki nbr kon ha
        for(int j = 0; j < g[0].length; j++){
            if(g[vtx][j] == 1 && vtx != j){
                graph[vtx].add(j);
                graph[j].add(vtx);
            }
        }
        
        // vtx ke col me chal ke dektna ha ki nbr kon ha
        for(int i = 0; i < g[0].length; i++){
            if(g[i][vtx] == 1 && i != vtx){
                graph[vtx].add(i);
                graph[i].add(vtx);
            }
        }
    }


//=================================================================================================================

// LC - Optimize Water Distribution in a Village  
// to submit =>   https://www.codingninjas.com/codestudio/problems/water-supply-in-a-village_1380956?leftPanelTab=1

// CONCEPT : since agar wells ka array na diya hota to simple haam MST ka cost nikal lete to find 
// the minimum cost to plant all the pipes. but question me haame wells khodne ke liye bhi bola ha agar cost minimum karni ha to
// so iss case me direct haam MST Algo(prims, kruskal) nahi laga sakte galat hoga as esa bhi case ho sakta ha jab saare wells khodna hi min cost ho

// HENCE, EK TRICK KHELTE HA HAAM (yahi catch ha):
// 1. ek new node bana lete ha let(x)
// 2. now haam sare nodes ko iss x se connect kar dete ha new edge bana ke jisme weight hoga wells[i] ie. wells ka cost 
// 3. now jo haamra new edges ka graph banega agar isme ab haam MST nikalege to vo minimum cost ayegi as haamne haar house me wells 
//    ko hata ke vaha bhi connection bana di pipe ki jisse ki  
//    [MST ka jo bhi cost ayega vo ek combine ans hoga = wells lagane ki cost + pipe lagane ki cost]

// NOTE : Now, since haame question me edges ki form me milega graph so haam mst nikalne ke liye kruskal Algo ka use karege
// as isme union find lagega and isme sirf edges chahiye hota ha

    static int[] par;
    public static int findParent(int u){
        if(u == par[u]) return u;
        int recans = findParent(par[u]);
        return par[u] = recans;
    }
    public static int supplyWater(int n, int k, int[] wells, int[][] pipes) {
        // build graph
        int num = pipes.length;
        int[][] edges = new int[num + n][num + n];
        int idx = 0;
        for(int i = 0; i < pipes.length; i++){
            int u = pipes[i][0], v = pipes[i][1], wt = pipes[i][2];
            edges[idx++] = new int[]{u, v, wt};
        }
        
        // adding new edges of wells 
        for(int i = 0; i < wells.length; i++){
            int u = i+1, v = n+1, wt = wells[i];   // v : ko haamne extra liya ha node to connect all the wells
            edges[idx++] = new int[]{u, v, wt};
        }
        
        // applying kruskal algorithm -> ie. UNION FIND
        Arrays.sort(edges, (a,b)->{
        return a[2]-b[2];  // this - other : ascending order sorting
        });
        
        par = new int[n+2];
        for(int i = 0; i < n+2; i++) par[i] = i; // suru me sab apne khud ke hi parent ha
        int cost = 0;
        for(int[] e : edges){
            int u = e[0], v = e[1], wt = e[2];
            int p1 = findParent(u);
            int p2 = findParent(v);
            
            if(p1 == p2){
                // cycle will not add in mst
            }else{
                // add in mst
                cost += wt;
                par[p1] = p2;  // merge the edge
            }
        }
        
        return cost;
    }



